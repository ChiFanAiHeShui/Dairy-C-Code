#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

int main() {

    //整形提升是按照数据类型的符号位来提升的
    char a = 3;
    //00000011 a
    /*
     变量a的二进制位（补码）中只有八个比特位：
     00000011
     因为char 为有符号的char
     所以整形提升的时候，高位补充符号位，即为1
     提升之后的结果为：
     00000000000000000000000000000011 a
    */

    char b = 127;
    //01111111 b


    char  c = a + b;
    // c  -10000010
    //a 和 b 如何相加
    //相加过程中在内存中，会默认进行整形提升。将a + b 的相加结果截断后，存到c中
    //00000000000000000000000000000011 a
    //00000000000000000000000001111111 b
    //00000000000000000000000010000010 c

    //c先进行整形提升然后存储到内存中去（补码） 

    //11111111111111111111111110000010 --补码
    //11111111111111111111111110000001 --反码
    //10000000000000000000000001111110 --源码
    // 所以c的输出结果为 ：-126
    printf("%d", c);// -126
    return 0;
}

//int main() {
//    int a = 1;
//    int b = 2;
//    int c = (a > b, a = b + 10, a, b = a + 1);//逗号表达式
//    printf("%d",c);//输出结果为13
//
//    return 0;
//}

//int main() {
//
//    int i = 0, a = 0, b = 2, c = 3, d = 4;
//    i = a++ && ++b && d++;//逻辑与&&，只要两边有一个为假，则为假。这里a++，所以a先为0，有假，后面不进行判断，因此b,d的值不变。
//    printf(" a = %d\n b = %d\n c = %d\n d = %d\n",a,b,c,d);//输出结果为1 2 3 4
//
//    printf("\n");
//    
//    i = 0, a = 0, b = 2, c = 3, d = 4;
//    i = a++ || ++b || d++;
//    printf(" a = %d\n b = %d\n c = %d\n d = %d\n", a, b, c, d);//输出结果为 1 3 3 4
//    return 0;
//}

//void test1(int arr[]) {
//
//    printf("%d\n",sizeof(arr));//8 传过来的参数为数组第一位的地址，所以这里的arr为指针变量，在64位机里长度为8
//
//}
//
//void test2(char ch[]) {
//
//    printf("%d\n", sizeof(ch));//8
//
//}
//
//int main() {
//    int arr[10] = {0};
//    char ch[10] = {0};
//    printf("%d\n",sizeof(arr));//40
//    printf("%d\n", sizeof(ch));//10
//    test1(arr);
//    test2(ch);
//
//    return 0;
//}

//int main(){
//
//    int  a = 11;
//    int b = a | (1 << 2);
//    printf("%d\n", b);//15
//    //00000000000000000000000000001011
//    //00000000000000000000000000000100
//    //00000000000000000000000000001111 --->结果为15
//
//    b = a & (~(1 << 2));
//    printf("%d\n",b);
//    //00000000000000000000000000001011
//    //00000000000000000000000000000100
//    
//    //11111111111111111111111111111011 ~之后的结果，~为所有二进制为按位取反
//    
//    //00000000000000000000000000001011 b最终的值，所以最终变回去了
//    return 0;
//
//}

//int main() {
//
//    //优解
//    int num = -1;
//    int i = 0;
//    int count = 0;
//    while (num) {
//        count++;
//        num = num & (num - 1);
//    }
//    printf("二进制中一的个数为 = %d\n",count);
//
//    /*较优解
//    
//    int num = -1;
//    int i = 0;
//    int count = 0;
//    for (int i = 0; i < 32; i++) {
//        if ( 1 == ((num >> i) & 1)) {
//            count++;
//        }
//    }
//    printf("二进制中1的个数为---> %d\n",count);*/
//    return 0;
//}


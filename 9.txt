1. assert()函数是断言函数

例子：
  char* p = NULL;
  assert(p != NULL);
  则在运行的时候，程序会直接报错。

2.const 可以修饰指针
  
  const放在*的左边（cosnt int* p;）
  const修饰的是 *p，表示p指向的对象不能通过p来改变，但是p变量中的地址是可以改变的
  
  const放在 * 的右边，（int * const p ;）
  const修饰的是p，表示p的内容不能被改变，但是p指向的对象是可以通过p来改变的。
  
  
3.为什么计算机中存储负整数的时候原,反,补码不同呢？并且内存中存储的都是补码呢？

   解释：主要是因为计算机的cpu只能进行加法运算。
   
   那么例如： 1-1
   这个式子是怎么计算的呢？
   实际上这个式子在内存中的显示是：1 + （-1）
   在计算机将其进行运算的时候，就把负数的补码和整数的补码进行相加（如果是原码相加则会出错），
   最后换成原码输出。
   
    注：在有符号的char类型当中，10000000会被直接解析为-128.
	（******负数要先化成原码再计算值）
	
4.
  %u --> 是打印无符号数，就算你是有符号的数，也认为是无符号数
  %d --> 是打印有符号数，就算你不是有符号数，也认为是有符号数


5.大小端字节序存储（内存中存储）
   
   大端字节序存储：把一个数据低位字节处的数据存放在高地址处
     （高低 低高） 把高位字节处的数据存放在低地址处
	
	
	小端字节序存储：把一个数据高位字节处的数据存放在低地址处
   （低低高高）     把低位字节处的数据存放在高地址处
					
					
	例子： int a = 0x11223344;
	 
	  内存地址
	  -------------------------------------------->
	  低                                     高
	 
	 
	 大端：11 22 33 44
     
	 小端：44 33 22 11	 
  


6.函数指针例子

int Add(int x, int y){
   return x + y;
}


int main(){

  int (*pf)(int,int) = Add;//这就是函数指针变量
  
  //利用pf指针来调用函数
  int ret = (*pf)(2,3);
  printf("%d \n",ret);

  return 0 ;
}


7.函数指针数组

int Add(int x, int y){
  return x + y;
}

int Sub(int x, int y){
  return x - y;
}

int main(){
  
  int (*  pf[2] )(int,int)= {Add,Sub};//函数指针数组
  
  //int a = 5;
  //其中，int是一个整型类型，相当于上面的int(*)(int,int), a是变量相当于上面的pf[2].
  return 0;
}

*****函数指针数组的作用是：转移表


8.回调函数

#include <stdio.h>

void test(){
    printf("HeHe\n");
}

void print_HeHe(void (*p)()){//这就是回调函数

}

int main(){
   
   print_HeHe(test);
 return 0;
}
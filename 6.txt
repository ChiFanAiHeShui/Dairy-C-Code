1.移位操作符

左移简单，右移稍微麻烦点


先讲左移运算符

注意，这里讲的都是整数
并且内存中存储的都是补码


正数的原，反，补码都是一样的
正整数的左移运算符：左边丢弃，右边补0


负整数的左移运算符：因为内存中存储的是数的补码，所以得先把负整数给化成补码
然后再左移，再左边丢弃，右边补0
再把移位后的补码给化成原码输出


负数化成补码的过程：先将负数的二进制数写出来，注意第一位是1，表示负数，其他直接计算，得到原码
然后原码除符号位外全取反，得到反码。
反码+1得到补码



右移运算符：

有两种方式：


算术右移：右边丢弃，左边补原符号位

逻辑右移：右边丢弃，左边补0

到底是选择算术右移还是逻辑右移，取决于你当前使用的编译器。


***对移位运算符，尽量不要移动负数位，这是标准未定义的



2.位操作符
  注意，它们全都是整数的二进制的补码来进行的比较的
    &                 |              ^
   按位与          按位或         按位异或
   全是1才是1      有1就是1     相异为1，相同为0
   有0就是0
   

3.C语言中，0表示假，非0表示真

4.EOF的本质是-1.当对-1进行按位取反运算后，得到的是0.
因为-1的补码全为1，这时当对它进行按位取反时，得到的数全是0.
   
   
5.逻辑操作符：      &&                    ||
                   逻辑与                逻辑或
                   全真为真             有真为真
				   有假为假           


6.下标引用操作符可以将括号外面的数组名字与括号内的参数进行交换也可以
相当于 ： a + b  = b + a;

7.#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

//int main() {
//
//	int a = 10;
//	short b = 9;
//
//	int ret = sizeof(b= a+ 1);
//	
//	 printf("%d %d ", ret,b);//输出结果为：2和9。输出9是因为sizeof括号里面的运算实际上不会进行的
//
//	return 0;
//}

8.
int main() {
	//经典面试题
	int i = 0, a = 0, b = 2, c = 3, d = 4;
	i = a++ && ++b && d++;
	printf("a = %d\n b = %d\n c = %d\n d = %d\n", a, b, c, d);




	return 0;


	//猜测输出结果，并且将a的值改变和将换个逻辑运算符来测试
}